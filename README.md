# paths_too_long

This a toolset was built to fix filepaths that have more characters than
the 260 character limit of the Windows documents server at the
university of California, Santa Cruz. It consists of three scripts: one
for scraping the server for file paths that are longer than the
character limit. The second script launches a gui for collecting the
desired corrections of the file paths from the user. And the third
script implements the path corrections from the second script. Here is a
more detailed breakdown of the three scripts: <br/> <br/>

###### paths_too_long.py

paths_too_long.py is a relatively simple script that prompt the user for
a path in the console and iterates through the directories within
populating a dataframe with the attributes of the files. It then removes
all the files that do not have a path length more than 260 characters.
THe resulting dataframe is saved into a csv file. <br/> <br/>

###### fix_paths2long.py

fix_paths2long.py launches a tkinter GUI using spreadsheet generated by
paths_too_long.py to elicit changes to directory names in the path from
the user that reduce the path length. It starts by eliciting the name of
the csv file. Note that the file should be in the same directory as the
fix_paths2long.py file. From the csv file a dataframe is generated and
iterated through each row, creating a tkinter frame for each path, the
ChooseSegmentFrame. An image of this frame can be found in image
'fix_paths2long-ChooseSegmentFrame-example.jpg'. This gui frame includes
four rows:
- Row 1 is just the entire path (the app window can become quite wide).
- Row 2 is a set of buttons that correspond to each directory in the
  path. Pushing one of these buttons selects the directory name to be
  change in the second tkinter frame.
- Row 3 is the number of other file paths in the dataframe that share
  the path up each directory in the path. This allows the user to know
  how many filepaths would be effected by changing the name of each
  directory in the path, facilitating batch changing of the filepath.
  This batch changing mechanism is the critical time-saving benefit of
  using these scripts.
- Row 4 has the length of the longest filepath from the dataframe that
  includes the corresponding directory. Note that the length of the
  current path (in row 1) is given at the last entry in this row. This
  row allows the user to know how many characters need to be removed
  from each directory in the filepath to meet the 260 character windows
  path limit.

When the button corresponding to a directory is selected from row 2 in
the ChooseSegmentFrame it is used to generate the next frame, called the
FixSegmentFrame. An image of this frame can be seen in
fix_paths2long-FixSegmentFrame-example.jpg. It includes the directory
name, a text entry box pre-populated with the directory name, an 'enter'
button, and a 'write changes to csv' button. The user should make the
desired changes to the directory name in the the text field and press
the 'enter' button which saves the name change into a modified path for
all the affected file paths in the dataframe. THe 'write changes to csv'
button on the FixSegmentFrame frame saves the dataframe with the
corrected paths to the csv file, effectively saving the users progress.
Note that the new shoretened filepath are now stored in an additional
row within the csv file. <br/> <br/>

###### apply_file2long_fixes.py

The purpose of this script is to realize the directory and file name
changes recorded in the fix_paths2long.py script. It starts by eliciting
the name of the csv file generated by paths_too_long.py with correction
by fix_paths2long.py. The csv file should be in the same directory as
the script. The script then goes through the dataframe generated from
the csv file, adding an additional attribute, 'depth', which is the
number directories between the directory that was changed in
fix_paths2long.py and the root. Then starting with file paths that
require the deepest directory or file name changes, the script iterates
through the dataframe making the desired change and recording the
changed path for all the affected rows of the dataframe in a column
labeled 'intermediary_paths'. The latest filepath change is recorded in
a 'result_path' column and if any errors are encountered when trying to
locate or change a path, those are recorded in an 'error' column. The
result is a dataframe where a list of all the filepath changes are
recorded into the intermediary_paths column, the actually resuling
location of the file is recorded in the result_path column. That
dataframe is then saved into the csv file.

